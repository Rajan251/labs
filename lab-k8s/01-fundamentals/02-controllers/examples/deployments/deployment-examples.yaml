# Deployment Examples
# Deployments manage ReplicaSets and provide declarative updates for Pods

# Example 1: Basic Deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
    app: nginx
spec:
  # Number of pod replicas
  replicas: 3
  
  # Selector to match pod labels
  selector:
    matchLabels:
      app: nginx
  
  # Pod template
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.25-alpine
        ports:
        - containerPort: 80
        resources:
          requests:
            memory: "64Mi"
            cpu: "100m"
          limits:
            memory: "128Mi"
            cpu: "200m"

---
# Example 2: Deployment with Rolling Update Strategy
apiVersion: apps/v1
kind: Deployment
metadata:
  name: webapp-deployment
  labels:
    app: webapp
spec:
  replicas: 5
  
  # Rolling update strategy
  strategy:
    type: RollingUpdate
    rollingUpdate:
      # Maximum number of pods that can be unavailable during update
      maxUnavailable: 1
      # Maximum number of pods that can be created over desired replicas
      maxSurge: 2
  
  selector:
    matchLabels:
      app: webapp
  
  template:
    metadata:
      labels:
        app: webapp
        version: v1
    spec:
      containers:
      - name: webapp
        image: myapp:1.0.0
        ports:
        - containerPort: 8080
          name: http
        
        # Health checks for rolling updates
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        
        readinessProbe:
          httpGet:
            path: /ready
            port: 8080
          initialDelaySeconds: 10
          periodSeconds: 5
        
        resources:
          requests:
            memory: "256Mi"
            cpu: "200m"
          limits:
            memory: "512Mi"
            cpu: "400m"

---
# Example 3: Deployment with Recreate Strategy
# All existing pods are killed before new ones are created
apiVersion: apps/v1
kind: Deployment
metadata:
  name: database-migration
  labels:
    app: db-migration
spec:
  replicas: 1
  
  # Recreate strategy - useful for stateful apps or migrations
  strategy:
    type: Recreate
  
  selector:
    matchLabels:
      app: db-migration
  
  template:
    metadata:
      labels:
        app: db-migration
    spec:
      containers:
      - name: migration
        image: migration-tool:1.0.0
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: db-credentials
              key: url
        resources:
          requests:
            memory: "512Mi"
            cpu: "500m"
          limits:
            memory: "1Gi"
            cpu: "1000m"

---
# Example 4: Deployment with Multiple Containers
apiVersion: apps/v1
kind: Deployment
metadata:
  name: multi-container-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: multi-app
  template:
    metadata:
      labels:
        app: multi-app
    spec:
      containers:
      # Main application
      - name: app
        image: myapp:1.0.0
        ports:
        - containerPort: 8080
        resources:
          requests:
            memory: "256Mi"
            cpu: "200m"
          limits:
            memory: "512Mi"
            cpu: "400m"
      
      # Sidecar: Metrics exporter
      - name: metrics
        image: metrics-exporter:1.0.0
        ports:
        - containerPort: 9090
        resources:
          requests:
            memory: "64Mi"
            cpu: "50m"
          limits:
            memory: "128Mi"
            cpu: "100m"

---
# Example 5: Deployment with Init Containers
apiVersion: apps/v1
kind: Deployment
metadata:
  name: init-deployment
spec:
  replicas: 2
  selector:
    matchLabels:
      app: init-app
  template:
    metadata:
      labels:
        app: init-app
    spec:
      # Init containers run before main containers
      initContainers:
      - name: wait-for-db
        image: busybox:1.36
        command:
        - 'sh'
        - '-c'
        - 'until nc -z postgres-service 5432; do echo waiting for db; sleep 2; done'
      
      containers:
      - name: app
        image: myapp:1.0.0
        ports:
        - containerPort: 8080
        resources:
          requests:
            memory: "256Mi"
            cpu: "200m"
          limits:
            memory: "512Mi"
            cpu: "400m"

---
# Example 6: Deployment with ConfigMap and Secret
apiVersion: apps/v1
kind: Deployment
metadata:
  name: config-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: config-app
  template:
    metadata:
      labels:
        app: config-app
    spec:
      containers:
      - name: app
        image: myapp:1.0.0
        
        # Environment variables from ConfigMap
        envFrom:
        - configMapRef:
            name: app-config
        
        # Specific environment variables from Secret
        env:
        - name: DATABASE_PASSWORD
          valueFrom:
            secretKeyRef:
              name: db-credentials
              key: password
        - name: API_KEY
          valueFrom:
            secretKeyRef:
              name: api-credentials
              key: api-key
        
        # Mount ConfigMap as volume
        volumeMounts:
        - name: config-volume
          mountPath: /etc/config
        
        resources:
          requests:
            memory: "256Mi"
            cpu: "200m"
          limits:
            memory: "512Mi"
            cpu: "400m"
      
      volumes:
      - name: config-volume
        configMap:
          name: app-config-files

---
# Example 7: Deployment with Node Affinity
apiVersion: apps/v1
kind: Deployment
metadata:
  name: affinity-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: affinity-app
  template:
    metadata:
      labels:
        app: affinity-app
    spec:
      # Node affinity - schedule on nodes with specific labels
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
            - matchExpressions:
              - key: disktype
                operator: In
                values:
                - ssd
          preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 1
            preference:
              matchExpressions:
              - key: zone
                operator: In
                values:
                - us-west-1a
      
      containers:
      - name: app
        image: myapp:1.0.0
        resources:
          requests:
            memory: "256Mi"
            cpu: "200m"
          limits:
            memory: "512Mi"
            cpu: "400m"

---
# Example 8: Deployment with Pod Anti-Affinity
# Spread pods across different nodes for high availability
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ha-deployment
spec:
  replicas: 5
  selector:
    matchLabels:
      app: ha-app
  template:
    metadata:
      labels:
        app: ha-app
    spec:
      # Pod anti-affinity - avoid scheduling on same node
      affinity:
        podAntiAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
          - labelSelector:
              matchExpressions:
              - key: app
                operator: In
                values:
                - ha-app
            topologyKey: kubernetes.io/hostname
      
      containers:
      - name: app
        image: myapp:1.0.0
        ports:
        - containerPort: 8080
        resources:
          requests:
            memory: "256Mi"
            cpu: "200m"
          limits:
            memory: "512Mi"
            cpu: "400m"

---
# Example 9: Deployment with Horizontal Pod Autoscaler
apiVersion: apps/v1
kind: Deployment
metadata:
  name: autoscale-deployment
spec:
  replicas: 2  # Initial replicas, HPA will adjust
  selector:
    matchLabels:
      app: autoscale-app
  template:
    metadata:
      labels:
        app: autoscale-app
    spec:
      containers:
      - name: app
        image: myapp:1.0.0
        ports:
        - containerPort: 8080
        resources:
          # MUST specify requests for HPA to work
          requests:
            memory: "256Mi"
            cpu: "200m"
          limits:
            memory: "512Mi"
            cpu: "400m"

---
# HPA for the deployment
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: autoscale-app-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: autoscale-deployment
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80

---
# Example 10: Deployment with Revision History Limit
apiVersion: apps/v1
kind: Deployment
metadata:
  name: revision-deployment
spec:
  replicas: 3
  
  # Number of old ReplicaSets to retain for rollback
  revisionHistoryLimit: 5
  
  # Minimum seconds pod should be ready before considered available
  minReadySeconds: 10
  
  # Maximum time for deployment to make progress
  progressDeadlineSeconds: 600
  
  selector:
    matchLabels:
      app: revision-app
  
  template:
    metadata:
      labels:
        app: revision-app
    spec:
      containers:
      - name: app
        image: myapp:1.0.0
        ports:
        - containerPort: 8080
        resources:
          requests:
            memory: "256Mi"
            cpu: "200m"
          limits:
            memory: "512Mi"
            cpu: "400m"
