# Advanced Linux File Management and I/O Redirection Guide

**Role:** Senior Linux Administrator
**Scope:** Enterprise Environment
**Objective:** Master advanced file operations, stream redirection, archiving, and troubleshooting.

---

## 1. Standard Streams and Redirection

In Linux, every process is initialized with three standard file descriptors. Understanding these is crucial for effective automation and logging.

### The Three Streams

| Descriptor | Name | ID | Description | Default Target |
| :--- | :--- | :--- | :--- | :--- |
| **STDIN** | Standard Input | 0 | Input fed into the command | Keyboard |
| **STDOUT** | Standard Output | 1 | Normal output of the command | Terminal Screen |
| **STDERR** | Standard Error | 2 | Error messages generated by the command | Terminal Screen |

### Redirection Operators

| Operator | Function | Example |
| :--- | :--- | :--- |
| `>` | Redirect STDOUT to a file (overwrite) | `ls > file list.txt` |
| `>>` | Redirect STDOUT to a file (append) | `echo "Done" >> log.txt` |
| `2>` | Redirect STDERR to a file | `find / -name key 2> errors.txt` |
| `&>` | Redirect **both** STDOUT and STDERR to a file | `make &> build.log` |
| `2>&1` | Redirect STDERR to where STDOUT is currently going | `cron_script.sh > log.txt 2>&1` |
| `<` | Redirect STDIN from a file | `mysql db_name < dump.sql` |

### Real-World Use Case: Logging Cron Jobs
When running unattended cron jobs, you must capture both success outputs and errors to debug issues.

**Scenario:** A nightly backup script runs at 2 AM. You want a daily log file, but you also want to keep a history of errors in a separate cumulative file.

```bash
# Crontab entry
0 2 * * * /usr/local/bin/backup.sh > /var/log/backup/daily.log 2>> /var/log/backup/errors.log
```
*   Standard output (success messages) overwrites `daily.log` each night (so you only see the latest status).
*   Standard error (failures) appends to `errors.log` (so you have a historical record of failures).

**Scenario:** Discarding all output (common for noisy tools).
```bash
* * * * * /path/to/script.sh > /dev/null 2>&1
```
*   Redirects STDOUT to the bit-bucket `/dev/null`.
*   Redirects STDERR to STDOUT (which is already going to null).

---

## 2. Advanced Search

### `find`: The Swiss Army Knife
The `find` command searches for files in a directory hierarchy.

*   **Syntax:** `find [path] [conditions] [actions]`

#### Key Search Criteria
1.  **By Size:**
    *   `find /var/log -size +100M` (Files larger than 100MB)
    *   `find /home -size -1G` (Files smaller than 1GB)
2.  **By Modification Time:**
    *   `find /tmp -mtime +7` (Modified more than 7 days ago)
    *   `find /var/backups -mtime -1` (Modified rarely than 24 hours ago)
3.  **By Permissions:**
    *   `find /var/www -perm 777` (Dangerous files with full read/write/execute for everyone)
    *   `find /usr/bin -perm /u+s` (Find SUID binaries)

### `grep`: Powerful Text Search
`grep` searches for patterns within files.

*   **Recursive Search:** `grep -r "pattern" /path`
*   **Case Insensitive:** `grep -i "pattern" /path`
*   **Show Line Numbers:** `grep -n "pattern" /path`

#### Optimizing Grep for Admins
**Scenario:** Searching for a configuration string `db_host` in `/etc`, but skipping the `.git` directory and showing only filenames.
```bash
grep -rl "db_host" /etc --exclude-dir=.git
```
*   `-r`: Recursive.
*   `-l`: List filenames only (suppress the matching line output).
*   `--exclude-dir`: vastly improves speed by ignoring irrelevant folders.

---

## 3. Archiving: `tar` and `rsync`

### `tar` (Tape ARchive)
`tar` is the standard for bundling files. Compression is added via flags.

#### Syntax & Compression Types
*   **Create Archive:** `tar -cvf archive.tar /path/to/files`
*   **Extract Archive:** `tar -xvf archive.tar`

| Flag | Compression | Extension | Speed vs. Ratio | Use Case |
| :--- | :--- | :--- | :--- | :--- |
| `-z` | **gzip** | `.tar.gz` | Fast / Moderate | General backups, logs |
| `-j` | **bzip2** | `.tar.bz2` | Slower / High | Long-term archiving, bandwidth constraint |
| `-J` | **xz** | `.tar.xz` | Slowest / Highest | Software distribution, kernels |

**Example:** Archiving logs with bzip2 for maximum space saving.
```bash
tar -cjvf logs_archive_$(date +%F).tar.bz2 /var/log/
```

### `rsync`: The King of Backups
`rsync` synchronizes files between locations. It is efficient because it only sends differences (deltas).

**Standard Backup Command:**
```bash
rsync -avz --delete /source/ /destination/
```
*   `-a`: Archive mode (preserves permissions, ownership, timestamps, symlinks). **Essential**.
*   `-v`: Verbose.
*   `-z`: Compress during transfer (good for network, skip for local).
*   `--delete`: **Caution!** Deletes files in `destination` that are not in `source`. Makes an exact mirror.

---

## 4. Troubleshooting

### Problem: "Permission denied"
You try to edit a file or run a script and are blocked.

1.  **Check basic modes:** `ls -l filename`
    *   Output: `-rw-r--r-- 1 root root ...`
    *   If you are not root, you cannot write. Use `sudo` or change invalid permissions.
    *   **Fix:** `chmod u+x script.sh` (Make executable) or `chown user:group file` (Fix ownership).
2.  **Check Attributes (The hidden lock):**
    *   If `root` gets "Permission denied", check for the **immutable bit**.
    *   **Check:** `lsattr filename`
    *   **Output:** `----i--------- filename` (The `i` means immutable).
    *   **Fix:** `chattr -i filename`
3.  **ACLs:** Standard permissions might be overridden.
    *   **Check:** `getfacl filename`

### Problem: "No space left on device"
You run `df -h` and see plenty of free space, yet you cannot write files.

1.  **Check Inodes:**
    *   Linux filesystems store metadata in inodes. If you have millions of tiny files, you can run out of inodes before running out of gigabytes.
    *   **Command:** `df -i`
    *   **Fix:** Delete directories with many small files (e.g., PHP sessions, mail queues).
2.  **Check Deleted but Open Files:**
    *   If a log file is deleted while a process (like Apache) is still writing to it, the space is not freed.
    *   **Command:** `lsof | grep deleted`
    *   **Output:** `apache2  1234  ...  /var/log/apache2/access.log (deleted)`
    *   **Fix:** Restart the process (`systemctl restart apache2`) to release the file handle.

---

## 5. Complex Command-Line Examples

These examples combine tools using pipes `|` and advanced options to solve real admin tasks.

### 1. Cleaning Old Log Files (Space Reclamation)
Find all log files in `/var/log` ending in `.log` that are larger than 100MB and were modified more than 30 days ago, then empty them (truncate) instead of deleting them (to preserve file handles).

```bash
find /var/log -name "*.log" -size +100M -mtime +30 -exec truncate -s 0 {} \;
```
*   `-exec ... \;`: Runs the command on every file found.
*   `truncate -s 0`: Sets file size to zero bytes without deleting the inode.

### 2. Security Audit: Finding IP Addresses in Logs
Extract unique IP addresses attempting SSH connections from `auth.log`, count them, and sort by frequency to spot attackers.

```bash
grep "Failed password" /var/log/auth.log | awk '{print $(NF-3)}' | sort | uniq -c | sort -nr | head -10
```
*   `grep`: Filters for failure lines.
*   `awk`: Extracts the IP column (usually 4th from end).
*   `sort | uniq -c`: Groups and counts occurrences.
*   `sort -nr`: Sorts numerically descending (top attackers first).

### 3. Selective Backup with Exclusions
Archive a web application directory but exclude the massive `uploads` folder and the `.git` directory.

```bash
tar -czvf webapp_backup.tar.gz /var/www/html --exclude='/var/www/html/uploads' --exclude='.git'
```
*   Note: Place `--exclude` flags *after* the create flag logic but usually before the path, though `tar` is flexible. Best practice varies by version, but explicit paths in exclude are safest.

### 4. Mass Permission Fix
Recursively set all Directories to 755 and all Files to 644 in a web folder. (Common security requirement).

```bash
find /var/www/html -type d -exec chmod 755 {} \; && find /var/www/html -type f -exec chmod 644 {} \;
```
*   `-type d`: Matches directories.
*   `-type f`: Matches files.
*   `&&`: Ensures the second command only runs if the first succeeds.

### 5. Monitoring Real-Time Log Activity covering multiple files
Watch multiple log files simultaneously for the word "Error" or "Exception", highlighting the match.

```bash
tail -f /var/log/syslog /var/log/nginx/error.log | grep --line-buffered --color=auto -E "Error|Exception"
```
*   `tail -f`: Follows multiple files.
*   `grep --line-buffered`: Flushes output immediately (crucial for pipes with `tail -f`).
*   `-E`: Extended regex for OR logic (`|`).
